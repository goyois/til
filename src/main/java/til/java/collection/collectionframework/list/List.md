
# ArrayList 

![](../../../../../../../../../nEoZSvi3dElf26DO80ljB-1657735127303.png)

- ArrayList 에서는 데이터를 추가 또는 삭제하려면 그림과 같이 다른 데이터를 복사해서 이동해야 한다.
- ArrayList에 객체를 순차적으로 저장할때는 데이터를 이동하지 ㅇ낳아도되므로 작업 속독 빠르지만, 중간에 위치한 객체를 추가 및 삭제할 때에는 데이터 이동이 많이 일어나므로 속도가 저하된다.
- 반면 인덱스가 n인 요소의 주소값을 얻기 위해서는 배열의 주소 + n * 데이터 타입의 크기 를 계산하여 데이터에 빠르게 접근이 가능하기 때문에 검색 측면에서는 유리함

## 효율적인 사항

- 데이터를 순차적으로 추가하거나 삭제하는 경우
- 데이터를 읽어들이는 경우

## 비효율적인 사항
- 중간에 데이터를 추가하거나, 중간에 위치하는 데이터를 삭제하는 경우
  (추가 또는 삭제 시 해당 데이터의 뒤에 위치한 값들을 뒤로 밀어주거나 앞으로 당겨주어야함)

&nbsp;
&nbsp;
&nbsp;
&nbsp;
# LinkedList

![](../../../../../../../../../otYh6ONO9GRELle0ohRlA-1657735168396.png)

Apple과 Orange 사이에 Mango라는 데이터를 추가하는 상황의 내부적 동작을 알아보자.

1. Mango 객체가 생성
2. Apple의 Next에 Mango의 주소값이 저장된다. (이 때 Mango의 Prev에 Apple의 주소값이 저장된다.)
3. Mango의 Next에 Orange의 주소값이 저장된다(이 때 Orange의 Prev에 Mango의 주소값이 저장된다.)

이처럼 LinkedList의 중간에 데이터를 추가하면 Next와 Prev에 저장되어 있는 주소값만 변경해주면 되므로, 각 요소들을 ArrayList처럼 뒤로 밀어내지 않아도 된다.
마찬가지로, 중간에 위치한 데이터를 삭제하는 경우에도 삭제한 데이터의 뒤로 위치하는 요소들을 앞으로 당기지 않아도 된다.

## 효율적인 사항

- 중간에 위치하는 데이터를 추가하거나 삭제하는 경우

## 비효율적인 사항

- 데이터를 검색할때는 시작 인덱스에서부터 찾고자하는 데이터까지 순차적으로 각 노드에 접근해야하기때문에 상대적으로 속도가 느림
